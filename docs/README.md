# 🎱 콘솔 로또 게임

로또 게임 프로젝트는 현실에서의 로또를 `Javascript` 프로그래밍 언어를 이용해 프로그램으로 구현한 프로젝트 입니다.  
구매할 로또 수량, 로또 당첨 번호, 로또 보너스 번호 정보를 얻은 후 당첨 내역과 수익률을 계산해줍니다.

## 게임 진행 방법

1. 로또 구매 수량을 입력합니다.

- 로또 구매 수량 규칙
  - 로또 구매 수량은 숫자여야 합니다.
  - 로또 한개의 가격인 1000의 배수여야 합니다.

2. 로또 당첨 번호를 입력합니다.

- 로또 당첨 번호 규칙
  - 로또 당첨 번호들은 모두 1~45 사이의 숫자여야 합니다.
  - 로또 당첨 번호들은 중복될 수 없습니다.

3. 로또 보너스 번호를 입력합니다.

- 로또 보너스 번호 규칙
  - 로또 보너스 번호는 1 ~ 45 사이의 숫자여야 합니다.
  - 이미 당첨 번호에 포함되어 있는 번호는 입력할 수 없습니다.

## 게임 진행 결과

![image](https://github.com/hwinkr/algorithm/assets/68489467/33b9b4db-2d69-419e-9869-2cde3d7e4882)

# 콘솔 로또 게임을 구현하기 위한 고민 & 기능 명세서

## 설계도

![image](https://github.com/woowacourse-precourse/javascript-lotto-6/assets/68489467/9c3bed5b-d11c-4201-ac04-e805125426b3)

## 도메인 로직

“소프트웨어가 해결하고자 하는 현실의 문제”를 소프트웨어 공학에서는 도메인이라고 표현하며 “도메인 로직”이란 그 현실의 문제를 해결해주는 코드를 의미합니다. 즉, 현실세계의 문제를 해결하기 위해서 직접적으로 관여를 하는 코드 덩어리라고 생각할 수 있습니다.

```
도메인 로직 == 현실 세계의 문제를 해결하기 위한 **의사결정을 하는 코드**
```

그렇다면, 도메인 로직을 통해 해결해야 하는 현실 문제인 “로또 게임”의 문제는 무엇일까에 대해서 생각해봤습니다. 한 문장으로 정리해보자면 **“과연, N개의 로또를 샀을 때 나의 당첨 내역과 수익률은 얼마인가?”라고 할 수 있습니다.** 이 문제를 해결하기 위한 목적을 가진 코드들을 묶어서 도메인 로직으로 표현하기로 했습니다.
그런데 “소프트웨어는 코드로 이루어져 있고, 그 코드들이 모여 현실 문제를 해결하니 소프트웨어의 모든 구성이 도메인 로직이 아닐까?” 라는 생각을 했습니다.

## 애플리케이션 서비스 로직

소프트웨어는 현실 세계의 문제를 직접적으로 해결하는 코드(도메인 로직) 이외에 다른 많은 코드들을 작성해야 합니다.

- 도메인 로직에 현실 문제를 전달(입력값 전달)
- 도메인 로직이 해결한 현실 문제를 출력

도메인 로직이 현실 문제를 해결하기 위해서는 도메인 로직에 문제를 전달해주는 로직도 필요합니다. 이 로직을 “애플리케이션 서비스 로직”이라고 합니다. 애플리케이션 서비스 로직은 **도메인 로직을 가능**하게 만듭니다. 예를 들어서, 데이터베이스를 통해서 현실 문제를 해결한다고 가정하면

- 데이터베이스에 로그인
- 백엔드 서버와 API를 통한 통신
- 사용자와의 인터렉션 처리

는 도메인 로직과 구분되는 애플리케이션 서비스 로직이라고 할 수 있습니다. 로또 게임에서 애플리케이션 서비스 로직이 될 수 있는 로직들에 대해서 생각해봤고,

1. 문제 해결을 위한 입력값 → 로또의 수익률을 판단하기 위해서 InputView를 통해서 로또 구매량, 로또 번호, 보너스 번호를 입력
2. 문제 해결 결과물을 해석하고 보여주고 전파 → 수익률을 판단하고 OutputView에 전파

로 정리할 수 있었습니다.

# 도메인 로직과 UI 로직을 분리하기

## 도메인 로직

> 도메인 로직을 통해서 해결해야 하는 “로또 게임”의 문제는 “과연, N개의 로또를 샀을 때 나의 당첨 내역과 수익률은 얼마인가?” 입니다. 이 문제에 직접적으로 관여하는 도메인들은 어떤 것들이 있는가에 대해서 정리한 후 각 도메인을 표현하는 클래스를 구현하기로 했습니다

### Lotto

> 구매한 한장의 로또를 표현하는 클래스

- [x] 필드(멤버 변수)를 구성한다.
- 로또 번호
- [x] 로또 번호가 유효하지 않을 경우 예외처리한다.
- [x] 유효성 검증
- `Number` 가 아닌 데이터 타입이 있는 경우
- 1 ~ 45 범위의 숫자가 아닌 숫자가 포함되어 있는 경우
- 6개의 숫자보다 적거나 많은 경우
- 중복된 숫자가 있는경우

**`Lotto` 클래스 기능 추가(2023.11.07)**

처음 로또 게임을 구현할 때는 `Lotto`클래스는 그저 **로또 종이 한장**을 표현하는 클래스에 불과하다고 생각했습니다. 하지만, 현실에서는 로또를 가지고 있는 사람이 로또 당첨 번호, 보너스 번호를 통해서 본인이 몇등인지 판단합니다. 이 생각을 바탕으로 `Lotto` 클래스에 **로또의 등수를 판단**한 후 반환하는 책임을 추가로 부여했습니다.

- [x] 로또의 등수를 판단한다.

### ~~LottoWinningNumber~~ -> LottoWinningInfo

**`LottoWinningNumber` 클래스 이름 변경(2023.11.07)**

기존 `LottoWinningNumber` 클래스는 로또의 당첨 번호, 보너스 번호를 멤버 변수로 가지는 클래스였습니다. 하지만 `winningNumber`는 로또의 당첨 번호만 표현한다는 느낌이 강해서 당첨 번호, 보너스 번호를 둘 다 표현할 수 있는 클래스 이름에 대해서 다시 고민했습니다. 그 후, 당첨 정보를 표현한다는 의미에서 `LottingWinningInfo`로 클래스 이름을 변경하기로 했습니다.

> 로또 당첨 번호를 표현하는 클래스

- [x] 필드를 구성한다.
- 로또 당첨번호
- 보너스 번호
- [x] 로또 당첨 번호, 보너스 번호가 유효성을 검증한다.

**로또 당첨 번호**

- 문자가 포함된 경우
- 1 ~ 45 범위의 숫자가 아닌 숫자가 포함되어 있는 경우
- 6개의 숫자보다 적거나 많은 경우
- 중복된 숫자가 있는경우

**보너스 번호**

- 문자가 포함된 경우
- 1 ~ 45 범위의 숫자가 아닌 숫자가 포함되어 있는 경우
- 당첨 번호에 이미 포함된 숫자를 입력하는 경우

- [x] ~~LottoJudge~~ -> `LottoResult`클래스에 당첨 번호, 보너스 번호를 전달한다.

### ~~Bonus~~

**`Bonus` 클래스 구현 취소(2023.11.07)**

로또 보너스 번호를 표현하는 `Bonus` 클래스는 로또 번호 보너스 번호만 가지고 있다가 필요할 때, 외부에 반환해주는 책임만 있는 클래스 입니다. 따라서, `Bonus` 클래스를 구현하지 않고 `LottoWinningInfo`에서 보너스 번호를 가지고 있을 수 있도록 변경했습니다

### ~~LottoJudge~~ -> LottoResult

**`LottoJudge` 클래스 이름 변경(2023.11.07)**

로또를 판단하는 동작을 표현하는 `LottoJudge`보다 로또를 샀을 때의 결과를 표현하는 이름인 `LottoResult`가 더 어울리는 것 같아 클래스 이름을 변경하기로 했습니다.

> 구입한 로또들의 결과(당첨 내역 및 수익률)를 판단하는 클래스

- [x] 필드를 구성한다
- ~~로또 당첨 번호(LottoWinningInfo)~~ -> `LottoDomainManager`에서 가지고 있는 것으로 변경
- 각 등수에 해당하는 로또가 몇장인지를 표현하는 객체

```js
#winningResult = {
  first: 0,
  second: 0,
  //...
};
```

- [x] 로또 당첨을 판단하는 메서드를 구현한다
- [x] 로또 수익률을 계산하는 메서드를 구현한다.

### LottoStore

**`LottoStore` 클래스 추가 구현(2023.11.07)**

`Lotto` 클래스를 통해서 로또 종이 한장을 표현한 뒤, **로또를 생성하는 책임은 누가 가져야 하는가?.**에 대해 고민 했습니다. 현실에서 로또 종이를 사려면 로또 판매점에 방문해야 하므로 로또 판매점을 `LottoStore` 클래스로 표현하기로 했습니다. `LottoStore`는 로또 번호를 랜덤으로 생성한 후 로또들을 생성하는 책임을 가집니다.

- [x] 필드를 구현한다
- pickLottoNumbers : 로또들의 숫자를 생성하는 함수  
  -> `pickLottoNumbers`를 멤버 변수로 둔 이유는, 로또들의 숫자를 생성하는 방법이 1 ~ 45 사이의 중복되지 않는 숫자 6개를 뽑는 방법 말고 충분히 다른 방법도 있을 수 있기 때문에 `LottoStore`클래스 내부에서 고정적으로 하나의 함수를 사용하기 보다 `LottoStore`클래스를 통해서 인스턴스를 생성할 때, 숫자를 생성하는 방법(함수)를 외부에서 주입할 수 있도록 하기 위해서 입니다.
- [x] 구매 수량의 유효성을 검증한다.
- 구매 수량이 숫자가 아닌 경우
- 구매 수량이 로또 하나의 가격으로 나누어 떨어지지 않는 경우
- [x] 구매 수량을 받아서 수량 만큼 로또를 생성한다.

### ~~LottoDomainManager~~ -> LottoManager

- [x] 필드를 구성한다
- ~~LottoWinningNumber~~ -> LottoWinningInfo
- ~~LottoJudge~~ -> LottoResult
- lottos(구매한 수량 만큼의 로또)

- [x] 로또 당첨 번호, 보너스 번호를 설정하는 메서드를 구현한다.
- [x] 구입금액 정보를 통해서 로또들을 생성한다
- [x] 로또 결과(당첨 결과, 수익률) 정보를 얻어온다.

## 애플리케이션 서비스 로직

> 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분하기 위해서 UI만 담당하는 애플리케이션 서비스 로직을 `InputView`, `OutputView` 클래스로 표현합니다.

### InputView

> 입력을 처리하는 메서드는 유효성 검증을 신경쓰지 않도록 구현했습니다. 유효성 검증은 클래스를 통해서 인스턴스를 생성할 때 하도록 했습니다.

- [x] 로또 구매 금액 입력받기
- [x] 로또 당첨번호 입력받기
- [x] 보너스 번호 입력받기

### OutputView

> 출력 과정에서 데이터를 조작하는 로직은 포함되지 않도록 했습니다. View는 UI를 담당하는 로직이므로, 비즈니스 로직이 없어야 하기 때문입니다. 비즈니스 로직이 없어야 한다는 것은, 예를 들어 로또 번호를 오름차순해서 보여줄 때, 오름차순은 신경쓰지 않아야 하고 소수점 둘 째 자리에서 반올림 하는것도 신경쓰지 않아야 합니다.

- [x] 발행한 로또 수량 및 번호를 출력한다.
- [x] 오름차순으로 정렬 된 로또 번호를 출력한다.
- [x] 당첨 내역을 출력한다
- [x] 소수점 둘 째 자리에서 반올림한 수익률을 출력한다
- [x] 에러 메세지를 출력한다.

### ~~ViewManager~~

**`ViewManager` 클래스 구현 취소(2023.11.08)**

## 컨트롤러

> 어딘가에서 도메인이 “~~한 일을 해야 한다”고 알려줘야 합니다. 이를 책임지는 컨트롤러 클래스도 구현하기로 했습니다. 그리고, 컨트롤러에서 더 추상화된 동작을 사용하기 위해서 로또 문제들을 해결하는 도메인들을 한번더 묶어서 관리하는(`LottoMannager`) 매니져 클래스도 구현하기로 했습니다.

- [x] 필드를 구성한다
- LottoDomainManager
- ~~ViewManager~~
- InputView
- OutputView
- [x] 로또 게임을 진행 시키는 메서드를 구현한다

## 기타

- [x] 로또 게임과 관련된 메시지 상수 객체로 만들기
- [x] 에러 메시지 상수 객체로 만들기
- [x] `Error` 클래스를 상속 받아서 구체적인 에러 발생시키기
- [x] 유효성 검증하는 함수 구현하기
- [x] 오름차순으로 정렬된 1 ~ 45 범위의 랜덤 숫자를 생성하는 함수 구현하기
- [x] try-catch문을 활용하여 유효하지 않은 값을 입력했을 경우 다시 입력받도록 하는 함수 구현하기

# 도메인 로직 단위 테스트

로또 게임 프로젝트에서 해결해야 하는 현실의 문제는 **“과연, N개의 로또를 샀을 때 나의 당첨 내역과 수익률은 얼마인가?”** 입니다. 이 문제를 해결하기 위해 직접적으로 관여하고 의사결정을 하는 코드들을 도메인 로직으로 표현했고,

- `Lotto`
- `LottoStore`
- `LottoResult`
- `LottoWinningInfo`

로 나눌 수 있었습니다.

## 단위 테스트?

단위 테스트는 **하나의 모듈을 기준으로 진행되는 가장 작은 테스트**입니다. 여기서 모듈은 소프트웨어 내부에서 동작하는 함수 또는 메서드라고 할 수 있습니다.  
단위 테스트는 소프트웨어를 구성하는 하나의 작은 기능이 예상대로 동작하는지를 독립적으로 테스트 하는 것입니다. 즉, **어떤 함수에 A라는 인자를 전달해서 호출하면 B라는 결과가 나온다**를 테스트합니다.

### 단위 테스트를 하는 이유

1. 소프트웨어를 구성하는 함수(메서드)의 정상 동작을 보장받을 수 있다.

소프트웨어를 구성하는 모든 함수(메서드)들 중 하나라도 버그가 발생 한다면, 소프트웨어의 동작에 영향을 미치기 때문에 함수의 정상 동작을 보장받는 것은 중요하다고 생각합니다.  
단위 테스트를 진행 하면서 구현한 함수에서 버그가 발생 한다면 빠르게 수정할 수 있고, 테스트의 결과를 통해서 작성한 코드들에 대해서 빠르게 피드백을 받을 수 있게 됩니다.

2. 테스트의 시간과 비용을 절약할 수 있다.

소프트웨어는 각 단위(함수, 메서드)들이 서로 상호작용 합니다. 소프트웨어 전체를 테스트 하기 위해서는 소프트웨어를 구성하는 모든 요소(front, back, infra...etc)들이 활성화 된 상태여야 하며 소프트웨어가 커질수록 테스트를 위한 비용도 증가하게 됩니다.  
단위 테스트는 소프트위에를 구성하는 가장 작은 단위를 독립적으로 테스트하기 때문에 테스트를 위한 시간, 비용도 크지 않고 구현 코드가 변경 되어도 빠르게 테스트 코드에 반영할 수 있게 됩니다.

3. 테스트 코드가 기능 명세서가 될 수 있다.

```js
describe('LottoStore 클래스 테스트', () => {
  // given
  let lottoStore;

  beforeEach(() => {
    lottoStore = new LottoStore();
  });

  test('구매 수량에 문자가 포함된 경우 예외가 발생한다.', () => {
    // when, then
    expect(() => {
      lottoStore.generateLottos('ab10');
    }).toThrow('[ERROR]');
  });

  test('구매 수량이 로또 하나의 가격으로 나누어 떨어지지 않는 경우 예외가 발생한다.', () => {
    // when, then
    expect(() => {
      lottoStore.generateLottos(1200);
    }).toThrow('[ERROR]');
  });

  test('로또 구매 수량만큼 로또를 생성한다', () => {
    // given
    const lottos = lottoStore.generateLottos(5000);

    // then
    expect(lottos.length).toBe(5);
    lottos.forEach((lotto) => {
      expect(lotto).toBeInstanceOf(Lotto);
    });
  });
});
```

위의 코드는 로또 게임을 구성하는 도메인 중 `LottoStore` 도메인에 대한 단위 테스트 코드입니다.
단위 테스트를 통해서 `LottoStore` 도메인이 어떤 책임을 가지고 있는지 확인할 수 있습니다. 단위 테스트를 통해서 `LottoStore`가 전체 소프트웨어(로또 게임)에서 어떤 동작을 하는지 확인할 수 있고 단위 테스트 자체가 `LottoStore`에 대한 기능 명세서가 될 수 있습니다.

## 단위 테스트 진행하기

### Lotto

- [x] 로또 번호가 유효하지 않을 경우 예외가 발생해야 한다.
- [x] 로또 번호를 외부에 전달할 때 메시지 형태로 전달해야 한다.
- [x] 로또 당첨 번호, 보너스 번호가 주어진 경우 등수 판단을 할 수 있어야 한다.

### LottoStore

- [x] 로또 구매 수량이 유요하지 않을 경우 예외가 발생해야 한다.
- [x] 로또 구매 수량 만큼 로또를 생성해야 한다

### LottoResult

- [x] 로또 당첨 결과의 초기 상태는 모두 0이어야 한다.

```js
this.#winningResult = {
  [LOTTO_RANKS.first]: 0,
  [LOTTO_RANKS.second]: 0,
  [LOTTO_RANKS.third]: 0,
  [LOTTO_RANKS.fourth]: 0,
  [LOTTO_RANKS.fifth]: 0,
};
```

- [x] 로또 당첨 결과는 외부에서 변경할 수 없어야 한다.
- [x] 로또 당첨 번호, 보너스 번호가 주어지면 로또 당첨 결과를 업데이트해야 한다.
- [x] 로또 당첨 결과, 로또 구매 수량이 주어지면 로또 수익률을 계산할 수 있어야 한다.
