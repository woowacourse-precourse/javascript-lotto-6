# 📖 사전 학습 📖

## 0. 클래스와 객체

<br>

### S-0-1. 클래스와 객체의 개념
  
  - `클래스`
    - 객체를 생성하기 위한 틀
    - ES6이후 도입
    - constructor() 메소드를 포함하여 객체가 생성될때 필요한 초기 상태를 설정한다
    - 클래스 안에는 객체의 행동을 정의하는 메소드들이 들어있다
  - `객체`
    - 클래스의 인스턴스
    - 클래스를 기반으로 생성된 실체
    - new 키워드를 사용하여 클래스의 인스턴스를 생성한다
    - 해당 클래스에 정의된 속성과 메소드를 사용할 수 있다

<br>

### S-0-2. 클래스와 객체를 분리하는 방법

  - `클래스 분리`
    - 클래스 정의를 별도의 파일로 만든다
    - 필요할 때마다 import를 사용하여 불러온다
    - 클래스를 분리하면 코드의 재사용성과 관리가 용이해진다
    - 모듈화를 통해 프로젝트의 구조를 더욱 명확하게 할 수 있다
    - 보통 소프트웨어의 설계 단계에서 고려된다
    - 구조적인 측면에서 모듈화에 초점을 맞춘다
  - `객체 분리`
    - 특정 객체의 생성과 관리하는 로직을 별도의 함수나 모듈로 만드는 것을 의미한다
    - 대규모 애플리케이션에서 객체의 생성과 관리를 캡슐화하고, 유지보수를 용이하게 한다
    - 생성 로직의 캡슐화와 관리의 용이성에 초점을 맞춘다

<br>

## 0. 도메인 로직과 단위 테스트

<br>

### S-0-3. 도메인 로직의 개념
  
  - `도메인 로직`
    - 특정 비즈니스 영역에 대한 규칙, 계산, 절차 등을 의미
    - 실제 비즈니스 문제를 해결하기 위한 소프트웨어 내부의 로직
    - ex) 쇼핑몰의 주문을 처리하는 과정, 재고 관리, 할인 적용
    - 시스템이 무엇을 할 것인지를 정의한다
    - UI 로직이나 데이터베이스와 같은 인프라 로직과 구분된다
  - `도메인 로직의 중요성`
    - 소프트웨어의 핵심 기능을 구현한다
    - 이를 통해 비즈니스 요구 사항을 만족시키고 사용자에게 가치를 제공한다
    - 잘 설계된 도메인 로직은 시스템의 유지보수와 확장성을 크게 향상시킨다
    - 비즈니스 규칙이 변경될 때 소프트웨어를 빠르고 쉽게 수정할 수 있도록 해준다
    - 개발자는 비즈니스 규칙에 집중할 수 있고, UI나 데이터베이스 설계는 비즈니스 로직으로부터 독립적으로 진행할 수 있다

<br>

### S-0-4. 도메인 로직에 대한 단위 테스트
  
  - `함수 단위 테스트`
    - 가장 작은 단위인 개별 함수 또는 메소드의 동작을 검증하는 테스트
    - 해당 함수가 올바른 인자를 받고 예상대로 결과를 반환하는지, 적절한 예외를 발생시키는 지 등을 확인
    - 주로 함수의 로직이 정확한지, 경계 조건과 에러처리가 적절한지에 중점
    - 구현의 정확성에 집중
    - 기술적인 측면에서의 검증
  - `도메인 단위 테스트`
    - 비즈니스 로직 또는 도메인 로직에 초점을 맞춘 테스트
    - 개별 기능을 넘어서 비즈니스 요구 사항을 정확하게 충족하는 지 검증
    - 비즈니스 프로세스의 흐름이나 상태 관리가 올바르게 이루어지는 지 테스트
    - 시스템이 실제 사용 환경에서의 비즈니스 목표를 달성할 수 있는 지 확인
    - 비즈니스 규칙과 요구 사항의 정확성에 집중
    - 비즈니스 로직의 검증
    - 종종 여러 함수가 통합되어 하나의 비즈니스 기능을 수행하는 것을 테스트한다
    - 고립된 함수의 동작을 넘어선다

<br>

---

<br>

# 🖋️ 배운 내용 🖋️

## 1. 로또 구입 금액 입력 받기

<br>

### T-1-1. 금액 입력 메세지 출력 테스트

  - `describe`
    - 관련된 테스트 케이스들을 그룹화한다
    - 이를 통해 테스트 코드를 더 관리하기 쉽고 구조화된 형태로 유지할 수 있다
  - `테스트 케이스`
    - test 또는 it 블록을 사용
    - 개별 테스트 케이스를 정의한다
    - 각 테스트 케이스는 독립적으로 실행되어야 한다
    - 테스트하려는 한 가지 구체적인 동작 또는 사례를 검증해야 한다
  - `모의 함수`
    - Jest의 jest.fn() 또는 jest.spyOn()을 사용
    - 함수를 모의한다
    - 함수 호출을 추적하거나, 함수의 반환 값을 조작하거나, 특정 함수가 호출되었는지 여부를 검사하는 데 사용
  - `Mock Module`
    - jest.mock()을 사용한다
    - 특정 모듈의 함수가 호출될 때 실제 구현 대신 테스트를 위한 구현을 사용하게 한다
    - 외부 시스템과의 의존성을 제거하고 테스트를 독립적으로 만든다
  - `비동기 테스트`
    - async/await를 사용
    - Jest는 비동기 코드가 완료될 때까지 기다린 후 테스트 결과를 확인할 수 있도록 지원한다
  - `생명주기 메서드`
    - beforeEach, beforeAll, afterEach, afterAll
    - 테스트 전과 후에 반복적으로 실행되어야 하는 코드를 작성한다
    - 예를 들어, beforeEach는 각 테스트가 시작하기 전에 실행되며, 테스트 환경을 초기화하는 데 유용하다
  - `expect`
    - 테스트에서 기대하는 조건을 명시한다
    - Jest는 다양한 matcher를 통해 값이나 객체가 특정 조건을 만족하는지 검사한다

<br>

### T-1-2. 금액 입력 처리 테스트

  - `dmockResolvedValue`
    - 비동기 함수가 특정 값을 반환하도록 설정할 수 있다
    - 이를 통해 Console.readLineAsync가 마치 사용자가 '8000'과 같은 유효한 금액을 입력한 것처럼 동작하게 할 수 있다