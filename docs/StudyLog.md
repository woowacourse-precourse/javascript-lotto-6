# 📖 사전 학습 📖

## 0. 클래스와 객체

<br>

### S-0-1. 클래스와 객체의 개념
  
  - `클래스`
    - 객체를 생성하기 위한 틀
    - ES6이후 도입
    - constructor() 메소드를 포함하여 객체가 생성될때 필요한 초기 상태를 설정한다
    - 클래스 안에는 객체의 행동을 정의하는 메소드들이 들어있다
  - `객체`
    - 클래스의 인스턴스
    - 클래스를 기반으로 생성된 실체
    - new 키워드를 사용하여 클래스의 인스턴스를 생성한다
    - 해당 클래스에 정의된 속성과 메소드를 사용할 수 있다

<br>

### S-0-2. 클래스와 객체를 분리하는 방법

  - `클래스 분리`
    - 클래스 정의를 별도의 파일로 만든다
    - 필요할 때마다 import를 사용하여 불러온다
    - 클래스를 분리하면 코드의 재사용성과 관리가 용이해진다
    - 모듈화를 통해 프로젝트의 구조를 더욱 명확하게 할 수 있다
    - 보통 소프트웨어의 설계 단계에서 고려된다
    - 구조적인 측면에서 모듈화에 초점을 맞춘다
  - `객체 분리`
    - 특정 객체의 생성과 관리하는 로직을 별도의 함수나 모듈로 만드는 것을 의미한다
    - 대규모 애플리케이션에서 객체의 생성과 관리를 캡슐화하고, 유지보수를 용이하게 한다
    - 생성 로직의 캡슐화와 관리의 용이성에 초점을 맞춘다

<br>

## 0. 도메인 로직과 단위 테스트

<br>

### S-0-3. 도메인 로직의 개념
  
  - `도메인 로직`
    - 특정 비즈니스 영역에 대한 규칙, 계산, 절차 등을 의미
    - 실제 비즈니스 문제를 해결하기 위한 소프트웨어 내부의 로직
    - ex) 쇼핑몰의 주문을 처리하는 과정, 재고 관리, 할인 적용
    - 시스템이 무엇을 할 것인지를 정의한다
    - UI 로직이나 데이터베이스와 같은 인프라 로직과 구분된다
  - `도메인 로직의 중요성`
    - 소프트웨어의 핵심 기능을 구현한다
    - 이를 통해 비즈니스 요구 사항을 만족시키고 사용자에게 가치를 제공한다
    - 잘 설계된 도메인 로직은 시스템의 유지보수와 확장성을 크게 향상시킨다
    - 비즈니스 규칙이 변경될 때 소프트웨어를 빠르고 쉽게 수정할 수 있도록 해준다
    - 개발자는 비즈니스 규칙에 집중할 수 있고, UI나 데이터베이스 설계는 비즈니스 로직으로부터 독립적으로 진행할 수 있다

<br>

### S-0-4. 도메인 로직에 대한 단위 테스트
  
  - `함수 단위 테스트`
    - 가장 작은 단위인 개별 함수 또는 메소드의 동작을 검증하는 테스트
    - 해당 함수가 올바른 인자를 받고 예상대로 결과를 반환하는지, 적절한 예외를 발생시키는 지 등을 확인
    - 주로 함수의 로직이 정확한지, 경계 조건과 에러처리가 적절한지에 중점
    - 구현의 정확성에 집중
    - 기술적인 측면에서의 검증
  - `도메인 단위 테스트`
    - 비즈니스 로직 또는 도메인 로직에 초점을 맞춘 테스트
    - 개별 기능을 넘어서 비즈니스 요구 사항을 정확하게 충족하는 지 검증
    - 비즈니스 프로세스의 흐름이나 상태 관리가 올바르게 이루어지는 지 테스트
    - 시스템이 실제 사용 환경에서의 비즈니스 목표를 달성할 수 있는 지 확인
    - 비즈니스 규칙과 요구 사항의 정확성에 집중
    - 비즈니스 로직의 검증
    - 종종 여러 함수가 통합되어 하나의 비즈니스 기능을 수행하는 것을 테스트한다
    - 고립된 함수의 동작을 넘어선다

<br>

---

<br>

# 🖋️ 배운 내용 🖋️

## 1. 로또 구입 금액 입력 받기

<br>

### T-1-1. 금액 입력 메세지 출력 테스트

  - `describe`
    - 관련된 테스트 케이스들을 그룹화한다
    - 이를 통해 테스트 코드를 더 관리하기 쉽고 구조화된 형태로 유지할 수 있다
  - `테스트 케이스`
    - test 또는 it 블록을 사용
    - 개별 테스트 케이스를 정의한다
    - 각 테스트 케이스는 독립적으로 실행되어야 한다
    - 테스트하려는 한 가지 구체적인 동작 또는 사례를 검증해야 한다
  - `모의 함수`
    - Jest의 jest.fn() 또는 jest.spyOn()을 사용
    - 함수를 모의한다
    - 함수 호출을 추적하거나, 함수의 반환 값을 조작하거나, 특정 함수가 호출되었는지 여부를 검사하는 데 사용
  - `Mock Module`
    - jest.mock()을 사용한다
    - 특정 모듈의 함수가 호출될 때 실제 구현 대신 테스트를 위한 구현을 사용하게 한다
    - 외부 시스템과의 의존성을 제거하고 테스트를 독립적으로 만든다
  - `비동기 테스트`
    - async/await를 사용
    - Jest는 비동기 코드가 완료될 때까지 기다린 후 테스트 결과를 확인할 수 있도록 지원한다
  - `생명주기 메서드`
    - beforeEach, beforeAll, afterEach, afterAll
    - 테스트 전과 후에 반복적으로 실행되어야 하는 코드를 작성한다
    - 예를 들어, beforeEach는 각 테스트가 시작하기 전에 실행되며, 테스트 환경을 초기화하는 데 유용하다
  - `expect`
    - 테스트에서 기대하는 조건을 명시한다
    - Jest는 다양한 matcher를 통해 값이나 객체가 특정 조건을 만족하는지 검사한다

<br>

### T-1-2. 금액 입력 처리 테스트

  - `mockResolvedValue`
    - 비동기 함수가 특정 값을 반환하도록 설정할 수 있다
    - 이를 통해 Console.readLineAsync가 마치 사용자가 '8000'과 같은 유효한 금액을 입력한 것처럼 동작하게 할 수 있다

<br>

### C-1-3. 금액 입력 예외 처리

  - `정규 표현식`
    - 문자열을 처리할 때 특정 패턴으로 문자열의 일부를 검색, 대체, 추출하는데 사용되는 형식 언어
    - 복잡한 문자열 처리를 위해 사용되며, 간단한 메소드 호출로 강력한 문자열 검색 및 대체 작업을 수행할 수 있다

  - `문자열 검증`
    - 사용자 입력이 특정 형식을 따르는지 검사할 때 사용 (예: 이메일, 전화번호)

  - `문자열 검색`
    - 대량의 텍스트에서 패턴에 맞는 문자열을 찾을 때 사용

  - `문자열 대체`
    - 텍스트 내에서 특정 패턴을 찾아 다른 문자열로 대체할 때 사용

  - `문자열 추출`
    - 텍스트에서 특정 데이터를 추출할 때 사용

  - `정규 표현식의 메소드`
    - test()
      - 주어진 문자열이 정규 표현식을 만족하는지 boolean으로 반환
    - exec()
      - 정규 표현식에 일치하는 문자열을 찾아 배열로 반환
    - match()
      - 문자열에 정규 표현식을 적용하여 일치하는 부분을 찾는다
    - replace()
      - 문자열에서 정규 표현식과 일치하는 부분을 다른 문자열로 대체

  - `정규 표현식의 플래그`
    - g (global)
      - 전역 검색을 수행하며 문자열 내의 모든 일치 항목을 찾는다
    - i (ignore case)
      - 대소문자를 구분하지 않고 검색
    - m (multiline)
      - 여러 줄의 문자열에서 검색을 수행할 때 사용

<br>

## 2. 로또 번호 발행

<br>

### C-2-1. 구입 금액에 따른 로또 발행
  
  - `Set`
    - 중복을 허용하지 않는 데이터 집합을 만들 때 유용하다
    - 로또 번호와 같이 고유한 값들의 집합을 생성할 때 Set을 사용하여 중복을 쉽게 제거할 수 있다

  - `static`
    -  클래스의 인스턴스 없이 호출할 수 있는 메소드를 생성할 수 있다
    -  주로 유틸리티 함수나, 특정 인스턴스에 종속되지 않는 기능을 수행할 때 사용된다
